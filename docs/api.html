<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>json‑seal - API</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <main>
    <h1>API Reference</h1>

    <p>
      json‑seal exposes a small, explicit API for generating signing keys,
      canonicalizing values, sealing payloads, and verifying signed envelopes.
      All operations use the RFC 8785 JSON Canonicalization Scheme and RSA‑PSS
      signatures.
    </p>

    <!-- generateKeyPair -->
    <h2>generateKeyPair()</h2>
    <p>
      Generates a new RSA‑PSS key pair suitable for signing and verifying
      JSON envelopes. Keys are returned as WebCrypto <code>CryptoKey</code>
      objects.
    </p>

    <pre><code>import { generateKeyPair } from "json-seal";

const { publicKey, privateKey } = await generateKeyPair();
</code></pre>

    <h3>Returns</h3>
    <ul>
      <li><strong>publicKey</strong> — RSA‑PSS public key</li>
      <li><strong>privateKey</strong> — RSA‑PSS private key</li>
    </ul>

    <!-- signPayload -->
    <h2>signPayload(value, privateKey, publicKey)</h2>
    <p>
      Canonicalizes the value using RFC 8785 and signs it using RSA‑PSS with
      SHA‑256. Returns a sealed JSON envelope containing the original payload,
      a timestamp, the signature, and the embedded public key.
    </p>

    <pre><code>import { signPayload } from "json-seal";

const sealed = await signPayload(
  { message: "hello" },
  privateKey,
  publicKey
);
</code></pre>

    <h3>Parameters</h3>
    <ul>
      <li><strong>value</strong> — any JSON‑serializable value</li>
      <li><strong>privateKey</strong> — RSA‑PSS private key used to sign</li>
      <li><strong>publicKey</strong> — RSA‑PSS public key to embed in the envelope</li>
    </ul>

    <h3>Returns</h3>
    <p>
      A sealed JSON envelope containing:
    </p>
    <ul>
      <li><code>version</code> — envelope format version</li>
      <li><code>timestamp</code> — ISO‑8601 timestamp</li>
      <li><code>payload</code> — the original value</li>
      <li><code>signature.algorithm</code> — always <code>RSA-PSS-SHA256</code></li>
      <li><code>signature.publicKey</code> — PEM‑encoded public key</li>
      <li><code>signature.value</code> — Base64 signature</li>
    </ul>

    <!-- verifyBackup -->
    <h2>verifyBackup(sealed)</h2>
    <p>
      Verifies the authenticity and integrity of a sealed envelope. The
      embedded public key is used to validate the RSA‑PSS signature.
    </p>

    <pre><code>import { verifyBackup } from "json-seal";

const result = await verifyBackup(sealed);

if (result.valid) {
  console.log("Authentic:", result.payload);
} else {
  console.error("Verification failed");
}
</code></pre>

    <h3>Returns</h3>
    <ul>
      <li><strong>valid</strong> — boolean indicating authenticity</li>
      <li><strong>payload</strong> — the original value (only if valid)</li>
    </ul>

    <!-- canonicalize -->
    <h2>canonicalize(value)</h2>
    <p>
      Converts a JavaScript value into a deterministic canonical representation
      using the RFC 8785 JSON Canonicalization Scheme. Used internally by
      <code>signPayload</code> and <code>verifyBackup</code>.
    </p>

    <pre><code>import { canonicalize } from "json-seal";

const text = canonicalize({ b: 2, a: 1 });
// {"a":1,"b":2}
</code></pre>

    <p><a href="index.html">← Back</a></p>
  </main>
</body>
</html>